# **Unidad 1**   
 ##### [√çndice](Indice.md)

## üìö Contenidos de la Unidad

### üß†üí° Algoritmos, pseudoc√≥digo, diagrama de flujo.

Los algoritmos son procesos limitados, que siguen una serie de instrucciones para llevar a cabo un tipo de tarea o resolver un problema. Son muy importantes en el mundo de la programaci√≥n y por eso es fundamental saber manejarse con ellos, por ello los pseudoc√≥digos son importantes, ya que ayudan a introducir a los estudiantes al mundo de la programaci√≥n de una manera m√°s sencilla y adaptarse m√°s rapido a ella. Por su parte los diagramas de flujo, al representarse de manera gr√°fica, son una forma mucho m√°s f√°cil de representar un algoritmo, haciendo que los estudiantes comprendan de una mejor manera qu√© funci√≥n tiene cada instrucci√≥n que escriben para crear un algoritmo y como este esta estructurado. A continuaci√≥n un ejercicio hecho en PSeInt con su respectivo diagrama de flujo:

Imagen No1-Pseudoc√≥digo 

<img width="500" height="400" alt="image" src="https://github.com/user-attachments/assets/d14e7c4f-fdbd-4cf0-beb9-f4b0427bee88" />

Imagen No2- Diagrama de flujo 

<img width="500" height="324" alt="image" src="https://github.com/user-attachments/assets/ed27fe4a-12b0-4ff0-84dd-61eefa12aa54" />

No fue f√°cil hacer esto en un principio, fue arduo el proceso de usar PSeInt, pues encontrar la forma de hacer que el programa hiciera lo que yo quer√≠a era lo m√°s complicado, asimismo identificar variables y f√≥rmulas resultaba complicado, m√°s que todo las variables, pero con el tiempo, y sobre todo pr√°ctica, logr√© hacer lo que queria de forma casi autom√°tica. Tambi√©n me ayud√≥ el guiarme de los diagramas de flujo, logre obtener una ayuda para poder visualizar mi trabajo de mejor manera y saber si lo que estaba escribiendo cumpl√≠a lo que realmente queria.

### üñ•Ô∏è Pruebas de escitorio.

Las pruebas de escritorio son muy √∫tiles a la hora de comprobar si tu algoritmo funciona bien. Consisten en utilizar los datos que t√∫ le brindaste al algoritmo y crear distintos casos a resolver con ayuda de ellos, al ser algo que se hace por uno mismo, facilita el comprobar si los resultados obtenidos se ven reflejados en el algoritmo, caso contrario, estar√≠a evidenciando fallas que hay que arreglar. Supongamos que cre√© un algoritmo que lleva a cabo operaciones matem√°ticas b√°sicas y quiero comprobar si esta funcionando bien, lo que tendria ser√≠a algo asi:

Tabla No1-Ejemplo de una prueba de escritorio.

| Casos | Datos de entrada     | Proceso                     | Datos de salida |
|-------|----------------------|-----------------------------|-----------------|
| 1     | A = 2 B= 3           | C= A+B*(A - B)              |-1               |
| 2     | A = 4.5 B= 8         | C= A+B*(A - B)              |-23.5            |
| 3     | A = 10.5 B= 2.5      | C= A+B*(A - B)              | 30.5            | 

Las pruebas tienen que ser exactas, contener los datos exactos que tiene el algoritmo para evitar confusiones a quien las vea. Si bien es una tarea ardua, al final vale la pena al tener una forma de comprobar la correcta funcionalidad de tu algoritmo.

### Programaci√≥n por bloques.

La programaci√≥n por bloques es una manera creativa y visual de ense√±ar a programar a los principiantes, con ayuda de siluetas coloridas, a diferencia del c√≥digo normal, que corresponde a un conjunto de instrucciones que permiten crear un algoritmo sencillo para completar ciertas tareas. Esto es de ayuda en un principio para ayudar al estudiante a adaptarse de mejor manera a las clases y entender de manera pr√°ctica c√≥mo se aplican los algoritmos para resolver problemas y llevar a cabo acciones requeridas, con ejemplos cotidianos.

Si bien parecen sencillos, realmente tienen su complejidad detr√°s, pero la compensan al ser bastante llamativos e interactivos, algunos ejemplos de los ejercicios que te puedes encontrar son estos:

Imagen No2-Encontrar el camino (simple)

<img width="650" height="250" alt="Captura de pantalla 2025-10-24 200253" src="https://github.com/user-attachments/assets/66f8432a-af7e-4850-8b92-a4824135ac6e" />

Imagen No3-Encontrar el camino (avanzado)

<img width="650" height="250" alt="Captura de pantalla 2025-10-24 205611" src="https://github.com/user-attachments/assets/47cb7daa-f1f3-4107-8e75-137272be0ddd" />

Imagen No4-Dibujar 

<img width="650" height="250" alt="Captura de pantalla 2025-10-24 213124" src="https://github.com/user-attachments/assets/57ca88c9-35bc-42a8-ba70-b8360ccfb4d9" />

Una vez llegas a los niveles complicados, se pone a prueba tu capacidad de razonar, para de esa manera utilizar los bloques a tu disposici√≥n de la manera m√°s eficiente. Es bastante entretenido y puedes quedarte unas horas intent√°nlo, mientras mas los pruebes mas te dar√°s cuenta de por qu√© son de ayuda para poder empezar a programar, fortalecen cualidades que ser√°n de ayuda mas adelante.

### Ejemplos de algoritmos con estructuras lineales/secuenciales.

Los algoritmos tienen distintos objetivos y en base a ellos se obtienen diversos tipos de estructuras algor√≠tmicas. Una de las m√°s sencillas es la estructura lineal/secuencial, cuyo algoritmo est√° estructurado de tal forma que ejecuta las instrucciones dadas de manera lineal, paso a paso, sin desviarse ni ramificarse, hace uso de las instrucciones m√°s simples. Siendo una estructura simple y directa, ayuda a generar en los principiantes m√°s conocimiento, al hacer que puedan entender c√≥mo trabaja un algoritmo, al  identificar qu√© tipo de estructura necesita su c√≥digo y c√≥mo funciona cada instrucci√≥n. A la par mejora su l√≥gica, razonamiento y criterio a la hora de intentar resolver tareas cotidianas con una programaci√≥n m√°s consciente y avanzada. 

Algo importante es empezar a dejar el pseudoc√≥digo atr√°s para migrar a un lenguaje de programci√≥n m√°s complejo como C, ya que con ello se podr√° empezar ya de manera m√°s formal y real a programar, al conocer c√≥mo estos lenguajes funcionan y trabajan, aunque sea solo con la intenci√≥n de implementar algoritmos simples para tareas f√°ciles el uso de programas como C ayuda a que se formen bases m√°s robustas y flexibles.

Si bien no es f√°cil cambiar a un lenguaje de programaci√≥n, con la pr√°ctica y un poco de esfuerzo por conocer c√≥mo trabaja, se puede llegar a dominar y a realizar lo que se hac√≠a en PSeInt en C, como en la siguiente imagen:

Imagen No5-Trabajo en Pseint 

<img width="486" height="261" alt="Captura de pantalla 2025-10-25 204509" src="https://github.com/user-attachments/assets/ab5a40d2-e5eb-4ad3-9c7b-930ff38bed76" />

Imagen No6-Paso a C

<img width="586" height="361" alt="Captura de pantalla 2025-10-25 204531" src="https://github.com/user-attachments/assets/7ffc2071-25ee-42a9-81bd-94e8551f51ae" />

Imagen No7-Compilaci√≥n y ejecuci√≥n

<img width="1278" height="307" alt="image" src="https://github.com/user-attachments/assets/f6851c1c-d6fe-481a-bca5-fdd6a7b56c4d" />

Hay que tener en cuenta que, a diferencia de PSeInt, en C se necesitan ciertos comandos para compilar y ejecutar un programa, por lo que es esencial aprend√©rselos de memoria para facilitar el trabajo. Para compilar se usa el comando "gcc NombreArchivo.c -o NombreArchivo" y para ejecutar el comando ".\NombreArchivo.exe".

### Principales dificultades en la aplicaci√≥n de los contenidos.

Como siempre ocurre al tratar de aprender algo nuevo, habr√° dificultades de manera directa, debido al poco conocimiento adquirido en dicha √°rea. Al principio se tuvo problemas con la sintaxis y la l√≥gica en la estructura que daba lugar a errores en el c√≥digo, asimismo, ya adentrado en lo que se refiere a lenguajes de programaci√≥n, la mayor dificultad fue el aprender qu√© hac√≠a cada signo y cada frase determinada, sobre todo porque se necesitaban seg√∫n lo que se quer√≠a que el programa hiciera, hab√≠a que tener varias cosas en mente al momento de programar en ellos. Sin embargo, con el tiempo estas dificultades fueron desapareciendo con la debida pr√°ctica, que hac√≠a que cada nuevo algoritmo creado fuera m√°s f√°cil de hacer, al tener en mente qu√© cosas deben contener.

### Reflexi√≥n cr√≠tica de los aprendizajes de la unidad.

Esta primera vez fue satisfactoria. Considerando que los aprendizajes adquiridos son s√≥lidos y relevantes, capaces de crear bases firmes para poder seguir adentr√°ndose mucho m√°s a fondo en el mundo de la programaci√≥n sin mucho problema. Los temas observados fueron bastante llevaderos y en ning√∫n momento se hicieron pesados, pues se dieron a conocer de una forma sencilla pero efectiva, sin abrumar con demasiados conceptos al estudiante y permiti√©ndole asimilarlos por medio de la pr√°ctica y error. Cada uno fue, de manera progresiva, apoy√°ndose en el anterior lo que permiti√≥ un avance seguro a temas m√°s complejos, desde nociones y conceptos b√°sicos de programaci√≥n, pasando por las formas m√°s simples de programar y entender de qu√© manera funcionaban, hasta llegar a programar de forma m√°s formal con lenguajes de programaci√≥n. Hasta el momento la materia ha cumplido con las expectativas y promete un muy buen primer acercamiento a la programaci√≥n, algo que agradezco mucho.

## üìò‚úçÔ∏è Tareas entregadas 


| Tema                                                                 | Tarea                 |
|----------------------------------------------------------------------|-----------------------|
| Herramientas de algoritmos (pseudoc√≥digo y diagramas de flujo).      | [Tarea-1](Tarea1.pdf) |
| Instalaci√≥n de lenguajes de programaci√≥n (C, Python o Java).         | [Tarea-2](Tarea2.pdf) |
| Primer acercamiento a la construcci√≥n de algoritmos con estructuras secuenciales en pseudoc√≥digo.| [Tarea-3](Tarea3.pdf) |
| Del dise√±o del algoritmo con estructuras secuenciales a la construcci√≥n del programa. | [Tarea-4](Tarea4.pdf) |

